/**
 * Sistema de Prote√ß√£o contra Malware e V√≠rus
 * Detecta e previne ataques de malware, v√≠rus e c√≥digos maliciosos
 */

import { securityLogger } from './securityLogger';
import { generateSecureToken, hash } from './encryption';
import { ENV_CONFIG } from '../config/environment';

// Tipos para prote√ß√£o contra malware
interface MalwareSignature {
  id: string;
  name: string;
  type: MalwareType;
  severity: ThreatSeverity;
  pattern: string | RegExp;
  description: string;
  family: string;
  confidence: number;
  active: boolean;
  lastUpdated: number;
  source: string;
}

interface MalwareThreat {
  id: string;
  type: MalwareType;
  severity: ThreatSeverity;
  name: string;
  description: string;
  signature: string;
  fileHash?: string;
  fileName?: string;
  fileSize?: number;
  detectionMethod: DetectionMethod;
  confidence: number;
  timestamp: number;
  source: string;
  blocked: boolean;
  quarantined: boolean;
  metadata: Record<string, any>;
}

interface FileAnalysis {
  fileName: string;
  fileSize: number;
  fileType: string;
  fileHash: string;
  isMalicious: boolean;
  riskScore: number;
  threats: MalwareThreat[];
  signatures: string[];
  behaviorAnalysis: BehaviorAnalysis;
  staticAnalysis: StaticAnalysis;
  timestamp: number;
  scanDuration: number;
}

interface BehaviorAnalysis {
  suspiciousAPIs: string[];
  networkConnections: NetworkConnection[];
  fileOperations: FileOperation[];
  registryOperations: RegistryOperation[];
  processCreation: ProcessCreation[];
  memoryOperations: MemoryOperation[];
  riskScore: number;
}

interface StaticAnalysis {
  entropy: number;
  packedSections: boolean;
  suspiciousStrings: string[];
  imports: string[];
  exports: string[];
  certificates: CertificateInfo[];
  metadata: FileMetadata;
  riskScore: number;
}

interface NetworkConnection {
  protocol: string;
  destination: string;
  port: number;
  suspicious: boolean;
  reason?: string;
}

interface FileOperation {
  operation: string;
  path: string;
  suspicious: boolean;
  reason?: string;
}

interface RegistryOperation {
  operation: string;
  key: string;
  value?: string;
  suspicious: boolean;
  reason?: string;
}

interface ProcessCreation {
  processName: string;
  commandLine: string;
  parentProcess: string;
  suspicious: boolean;
  reason?: string;
}

interface MemoryOperation {
  operation: string;
  address: string;
  size: number;
  suspicious: boolean;
  reason?: string;
}

interface CertificateInfo {
  issuer: string;
  subject: string;
  valid: boolean;
  trusted: boolean;
  expired: boolean;
}

interface FileMetadata {
  version: string;
  company: string;
  description: string;
  copyright: string;
  originalFilename: string;
}

interface MalwareAlert {
  id: string;
  type: AlertType;
  severity: ThreatSeverity;
  title: string;
  message: string;
  threatId: string;
  fileName?: string;
  fileHash?: string;
  timestamp: number;
  acknowledged: boolean;
  actions: string[];
  quarantined: boolean;
}

interface MalwareStatistics {
  totalScans: number;
  threatsDetected: number;
  filesQuarantined: number;
  malwareBlocked: number;
  virusesDetected: number;
  trojansDetected: number;
  wormsDetected: number;
  spywareDetected: number;
  adwareDetected: number;
  rootkitsDetected: number;
  topMalwareFamilies: Array<{ family: string; count: number }>;
  detectionAccuracy: number;
  averageScanTime: number;
}

type MalwareType = 'VIRUS' | 'TROJAN' | 'WORM' | 'SPYWARE' | 'ADWARE' | 'ROOTKIT' | 'RANSOMWARE' | 'BACKDOOR' | 'KEYLOGGER' | 'BOTNET' | 'SUSPICIOUS';
type ThreatSeverity = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
type DetectionMethod = 'SIGNATURE' | 'HEURISTIC' | 'BEHAVIOR' | 'MACHINE_LEARNING' | 'SANDBOX';
type AlertType = 'MALWARE_DETECTED' | 'VIRUS_FOUND' | 'SUSPICIOUS_BEHAVIOR' | 'FILE_QUARANTINED';

// Assinaturas de malware conhecidas
const MALWARE_SIGNATURES: MalwareSignature[] = [
  {
    id: 'virus-001',
    name: 'Generic.Virus.A',
    type: 'VIRUS',
    severity: 'HIGH',
    pattern: /\x4D\x5A.{58}\x50\x45\x00\x00/,
    description: 'V√≠rus gen√©rico detectado',
    family: 'Generic',
    confidence: 85,
    active: true,
    lastUpdated: Date.now(),
    source: 'INTERNAL'
  },
  {
    id: 'trojan-001',
    name: 'Trojan.Generic.B',
    type: 'TROJAN',
    severity: 'CRITICAL',
    pattern: /CreateRemoteThread|WriteProcessMemory|VirtualAllocEx/,
    description: 'Trojan com capacidades de inje√ß√£o',
    family: 'Generic',
    confidence: 90,
    active: true,
    lastUpdated: Date.now(),
    source: 'INTERNAL'
  },
  {
    id: 'ransomware-001',
    name: 'Ransomware.Crypto',
    type: 'RANSOMWARE',
    severity: 'CRITICAL',
    pattern: /CryptEncrypt|CryptDecrypt|\.encrypted|\.locked/,
    description: 'Ransomware com capacidades de criptografia',
    family: 'Crypto',
    confidence: 95,
    active: true,
    lastUpdated: Date.now(),
    source: 'INTERNAL'
  },
  {
    id: 'keylogger-001',
    name: 'Spyware.Keylogger',
    type: 'KEYLOGGER',
    severity: 'HIGH',
    pattern: /SetWindowsHookEx|GetAsyncKeyState|keylog/i,
    description: 'Keylogger detectado',
    family: 'Keylogger',
    confidence: 88,
    active: true,
    lastUpdated: Date.now(),
    source: 'INTERNAL'
  },
  {
    id: 'backdoor-001',
    name: 'Backdoor.Remote',
    type: 'BACKDOOR',
    severity: 'CRITICAL',
    pattern: /bind|listen|accept|reverse.shell/i,
    description: 'Backdoor com acesso remoto',
    family: 'Remote',
    confidence: 92,
    active: true,
    lastUpdated: Date.now(),
    source: 'INTERNAL'
  }
];

// Strings suspeitas comuns
const SUSPICIOUS_STRINGS = [
  'cmd.exe', 'powershell.exe', 'regsvr32.exe', 'rundll32.exe',
  'CreateProcess', 'ShellExecute', 'WinExec', 'system(',
  'eval(', 'exec(', 'shell_exec', 'passthru',
  'base64_decode', 'gzinflate', 'str_rot13',
  'document.write', 'innerHTML', 'outerHTML',
  'XMLHttpRequest', 'ActiveXObject', 'WScript.Shell',
  'keylog', 'password', 'credential', 'token',
  'bitcoin', 'wallet', 'cryptocurrency', 'mining'
];

// APIs suspeitas
const SUSPICIOUS_APIS = [
  'CreateRemoteThread', 'WriteProcessMemory', 'VirtualAllocEx',
  'SetWindowsHookEx', 'GetAsyncKeyState', 'FindWindow',
  'RegCreateKey', 'RegSetValue', 'RegDeleteKey',
  'CreateFile', 'WriteFile', 'DeleteFile',
  'CreateService', 'StartService', 'ControlService',
  'CryptEncrypt', 'CryptDecrypt', 'CryptGenKey',
  'InternetOpen', 'InternetConnect', 'HttpSendRequest'
];

// Extens√µes de arquivo perigosas
const DANGEROUS_EXTENSIONS = new Set([
  '.exe', '.scr', '.bat', '.cmd', '.com', '.pif', '.vbs', '.js',
  '.jar', '.app', '.deb', '.pkg', '.dmg', '.msi', '.dll',
  '.sys', '.drv', '.ocx', '.cpl', '.inf', '.reg'
]);

// Classe principal de prote√ß√£o contra malware
export class MalwareProtection {
  private static instance: MalwareProtection;
  private signatures: Map<string, MalwareSignature> = new Map();
  private threats: Map<string, MalwareThreat> = new Map();
  private alerts: MalwareAlert[] = [];
  private quarantine: Map<string, FileAnalysis> = new Map();
  private scanHistory: Map<string, FileAnalysis> = new Map();
  private isEnabled = true;
  private realTimeProtection = true;
  
  private constructor() {
    this.loadSignatures();
    this.startRealTimeProtection();
  }
  
  static getInstance(): MalwareProtection {
    if (!MalwareProtection.instance) {
      MalwareProtection.instance = new MalwareProtection();
    }
    return MalwareProtection.instance;
  }
  
  /**
   * Escaneia um arquivo para detectar malware
   */
  async scanFile(file: File | ArrayBuffer, fileName?: string): Promise<FileAnalysis> {
    const startTime = Date.now();
    
    if (!this.isEnabled) {
      return this.createCleanAnalysis(fileName || 'unknown', 0, startTime);
    }
    
    try {
      let buffer: ArrayBuffer;
      let name: string;
      let size: number;
      
      if (file instanceof File) {
        buffer = await file.arrayBuffer();
        name = file.name;
        size = file.size;
      } else {
        buffer = file;
        name = fileName || 'unknown';
        size = buffer.byteLength;
      }
      
      // Verificar se arquivo j√° foi escaneado
      const fileHash = await this.calculateFileHash(buffer);
      const cached = this.scanHistory.get(fileHash);
      if (cached && Date.now() - cached.timestamp < 3600000) { // 1 hora
        return cached;
      }
      
      // Verificar extens√£o perigosa
      const extension = name.toLowerCase().substring(name.lastIndexOf('.'));
      let riskScore = DANGEROUS_EXTENSIONS.has(extension) ? 30 : 0;
      
      // An√°lise est√°tica
      const staticAnalysis = await this.performStaticAnalysis(buffer, name);
      riskScore += staticAnalysis.riskScore;
      
      // An√°lise comportamental (simulada)
      const behaviorAnalysis = await this.performBehaviorAnalysis(buffer, name);
      riskScore += behaviorAnalysis.riskScore;
      
      // Detec√ß√£o por assinatura
      const signatureThreats = await this.detectBySignature(buffer, name);
      
      // Detec√ß√£o heur√≠stica
      const heuristicThreats = await this.detectByHeuristics(buffer, name, staticAnalysis);
      
      const allThreats = [...signatureThreats, ...heuristicThreats];
      
      // Calcular score final
      if (allThreats.length > 0) {
        const maxThreatScore = Math.max(...allThreats.map(t => t.confidence));
        riskScore = Math.max(riskScore, maxThreatScore);
      }
      
      const isMalicious = riskScore > 70 || allThreats.some(t => t.severity === 'CRITICAL');
      
      const analysis: FileAnalysis = {
        fileName: name,
        fileSize: size,
        fileType: this.detectFileType(buffer),
        fileHash,
        isMalicious,
        riskScore: Math.min(riskScore, 100),
        threats: allThreats,
        signatures: allThreats.map(t => t.signature),
        behaviorAnalysis,
        staticAnalysis,
        timestamp: Date.now(),
        scanDuration: Date.now() - startTime
      };
      
      // Salvar no hist√≥rico
      this.scanHistory.set(fileHash, analysis);
      
      // Quarentena se malicioso
      if (isMalicious) {
        await this.quarantineFile(analysis);
      }
      
      // Log da an√°lise
      await securityLogger.logEvent(
        'MALWARE_SCAN',
        isMalicious ? 'HIGH' : 'LOW',
        'Arquivo escaneado para malware',
        {
          fileName: name,
          fileSize: size,
          fileHash,
          isMalicious,
          riskScore: analysis.riskScore,
          threatsFound: allThreats.length,
          scanDuration: analysis.scanDuration
        }
      );
      
      return analysis;
      
    } catch (error) {
      await securityLogger.logEvent(
        'MALWARE_SCAN_ERROR',
        'MEDIUM',
        'Erro no escaneamento de malware',
        { fileName, error: error.message }
      );
      
      return this.createErrorAnalysis(fileName || 'unknown', startTime);
    }
  }
  
  /**
   * Escaneia m√∫ltiplos arquivos
   */
  async scanFiles(files: File[]): Promise<FileAnalysis[]> {
    const results: FileAnalysis[] = [];
    
    for (const file of files) {
      const analysis = await this.scanFile(file);
      results.push(analysis);
    }
    
    return results;
  }
  
  /**
   * Escaneia texto/c√≥digo para detectar malware
   */
  async scanText(text: string, context?: string): Promise<{
    isMalicious: boolean;
    riskScore: number;
    threats: MalwareThreat[];
    suspiciousPatterns: string[];
  }> {
    if (!this.isEnabled) {
      return {
        isMalicious: false,
        riskScore: 0,
        threats: [],
        suspiciousPatterns: []
      };
    }
    
    const threats: MalwareThreat[] = [];
    const suspiciousPatterns: string[] = [];
    let riskScore = 0;
    
    // Verificar strings suspeitas
    for (const suspiciousString of SUSPICIOUS_STRINGS) {
      if (text.toLowerCase().includes(suspiciousString.toLowerCase())) {
        suspiciousPatterns.push(suspiciousString);
        riskScore += 10;
      }
    }
    
    // Verificar padr√µes de malware
    for (const signature of this.signatures.values()) {
      if (signature.active && typeof signature.pattern === 'string') {
        if (text.includes(signature.pattern)) {
          const threat = await this.createThreat(
            signature.type,
            signature.severity,
            signature.name,
            signature.description,
            signature.id,
            'SIGNATURE',
            signature.confidence,
            { context, pattern: signature.pattern }
          );
          threats.push(threat);
          riskScore = Math.max(riskScore, signature.confidence);
        }
      } else if (signature.pattern instanceof RegExp) {
        if (signature.pattern.test(text)) {
          const threat = await this.createThreat(
            signature.type,
            signature.severity,
            signature.name,
            signature.description,
            signature.id,
            'SIGNATURE',
            signature.confidence,
            { context, pattern: signature.pattern.toString() }
          );
          threats.push(threat);
          riskScore = Math.max(riskScore, signature.confidence);
        }
      }
    }
    
    // Verificar obfusca√ß√£o
    const obfuscationScore = this.detectObfuscation(text);
    riskScore += obfuscationScore;
    
    if (obfuscationScore > 30) {
      suspiciousPatterns.push('C√≥digo obfuscado detectado');
    }
    
    const isMalicious = riskScore > 60 || threats.some(t => t.severity === 'CRITICAL');
    
    if (isMalicious || threats.length > 0) {
      await securityLogger.logEvent(
        'MALWARE_TEXT_SCAN',
        isMalicious ? 'HIGH' : 'MEDIUM',
        'Texto escaneado para malware',
        {
          context,
          isMalicious,
          riskScore,
          threatsFound: threats.length,
          suspiciousPatterns: suspiciousPatterns.length
        }
      );
    }
    
    return {
      isMalicious,
      riskScore: Math.min(riskScore, 100),
      threats,
      suspiciousPatterns
    };
  }
  
  /**
   * Adiciona uma nova assinatura de malware
   */
  async addSignature(signature: Omit<MalwareSignature, 'id' | 'lastUpdated'>): Promise<void> {
    const id = await generateSecureToken(16);
    const newSignature: MalwareSignature = {
      ...signature,
      id,
      lastUpdated: Date.now()
    };
    
    this.signatures.set(id, newSignature);
    
    await securityLogger.logEvent(
      'MALWARE_SIGNATURE_ADDED',
      'MEDIUM',
      'Nova assinatura de malware adicionada',
      {
        signatureId: id,
        name: signature.name,
        type: signature.type,
        severity: signature.severity
      }
    );
  }
  
  /**
   * Remove um arquivo da quarentena
   */
  async removeFromQuarantine(fileHash: string, reason: string): Promise<void> {
    const quarantinedFile = this.quarantine.get(fileHash);
    if (quarantinedFile) {
      this.quarantine.delete(fileHash);
      
      await securityLogger.logEvent(
        'FILE_REMOVED_FROM_QUARANTINE',
        'MEDIUM',
        'Arquivo removido da quarentena',
        {
          fileName: quarantinedFile.fileName,
          fileHash,
          reason
        }
      );
    }
  }
  
  /**
   * Obt√©m estat√≠sticas de prote√ß√£o
   */
  getStatistics(): MalwareStatistics {
    const scans = Array.from(this.scanHistory.values());
    const threats = Array.from(this.threats.values());
    
    const totalScans = scans.length;
    const threatsDetected = threats.length;
    const filesQuarantined = this.quarantine.size;
    const malwareBlocked = threats.filter(t => t.blocked).length;
    
    // Contar por tipo
    const virusesDetected = threats.filter(t => t.type === 'VIRUS').length;
    const trojansDetected = threats.filter(t => t.type === 'TROJAN').length;
    const wormsDetected = threats.filter(t => t.type === 'WORM').length;
    const spywareDetected = threats.filter(t => t.type === 'SPYWARE').length;
    const adwareDetected = threats.filter(t => t.type === 'ADWARE').length;
    const rootkitsDetected = threats.filter(t => t.type === 'ROOTKIT').length;
    
    // Top fam√≠lias de malware
    const familyCounts = new Map<string, number>();
    for (const signature of this.signatures.values()) {
      const count = familyCounts.get(signature.family) || 0;
      familyCounts.set(signature.family, count + 1);
    }
    
    const topMalwareFamilies = Array.from(familyCounts.entries())
      .map(([family, count]) => ({ family, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
    
    // Precis√£o da detec√ß√£o (simulada)
    const detectionAccuracy = 96.8;
    
    // Tempo m√©dio de escaneamento
    const averageScanTime = scans.length > 0 
      ? scans.reduce((sum, scan) => sum + scan.scanDuration, 0) / scans.length
      : 0;
    
    return {
      totalScans,
      threatsDetected,
      filesQuarantined,
      malwareBlocked,
      virusesDetected,
      trojansDetected,
      wormsDetected,
      spywareDetected,
      adwareDetected,
      rootkitsDetected,
      topMalwareFamilies,
      detectionAccuracy,
      averageScanTime
    };
  }
  
  /**
   * Obt√©m amea√ßas detectadas
   */
  getThreats(type?: MalwareType, severity?: ThreatSeverity): MalwareThreat[] {
    let threats = Array.from(this.threats.values());
    
    if (type) {
      threats = threats.filter(t => t.type === type);
    }
    
    if (severity) {
      threats = threats.filter(t => t.severity === severity);
    }
    
    return threats.sort((a, b) => b.timestamp - a.timestamp);
  }
  
  /**
   * Obt√©m arquivos em quarentena
   */
  getQuarantinedFiles(): FileAnalysis[] {
    return Array.from(this.quarantine.values())
      .sort((a, b) => b.timestamp - a.timestamp);
  }
  
  /**
   * Obt√©m alertas
   */
  getAlerts(acknowledged = false): MalwareAlert[] {
    return this.alerts
      .filter(alert => alert.acknowledged === acknowledged)
      .sort((a, b) => b.timestamp - a.timestamp);
  }
  
  /**
   * Marca um alerta como reconhecido
   */
  acknowledgeAlert(alertId: string): void {
    const alert = this.alerts.find(a => a.id === alertId);
    if (alert) {
      alert.acknowledged = true;
    }
  }
  
  /**
   * Habilita/desabilita prote√ß√£o em tempo real
   */
  setRealTimeProtection(enabled: boolean): void {
    this.realTimeProtection = enabled;
    
    if (enabled) {
      this.startRealTimeProtection();
    }
  }
  
  // M√©todos privados
  private async performStaticAnalysis(buffer: ArrayBuffer, fileName: string): Promise<StaticAnalysis> {
    const data = new Uint8Array(buffer);
    let riskScore = 0;
    
    // Calcular entropia
    const entropy = this.calculateEntropy(data);
    if (entropy > 7.5) {
      riskScore += 20; // Alta entropia pode indicar packing/criptografia
    }
    
    // Verificar se√ß√µes empacotadas (simulado)
    const packedSections = entropy > 7.8;
    if (packedSections) {
      riskScore += 30;
    }
    
    // Procurar strings suspeitas
    const text = new TextDecoder('utf-8', { fatal: false }).decode(buffer);
    const suspiciousStrings = SUSPICIOUS_STRINGS.filter(str => 
      text.toLowerCase().includes(str.toLowerCase())
    );
    riskScore += suspiciousStrings.length * 5;
    
    // Procurar APIs suspeitas
    const imports = SUSPICIOUS_APIS.filter(api => 
      text.includes(api)
    );
    riskScore += imports.length * 10;
    
    return {
      entropy,
      packedSections,
      suspiciousStrings,
      imports,
      exports: [], // Simulado
      certificates: [], // Simulado
      metadata: {
        version: '',
        company: '',
        description: '',
        copyright: '',
        originalFilename: fileName
      },
      riskScore: Math.min(riskScore, 100)
    };
  }
  
  private async performBehaviorAnalysis(buffer: ArrayBuffer, fileName: string): Promise<BehaviorAnalysis> {
    // An√°lise comportamental simulada
    const text = new TextDecoder('utf-8', { fatal: false }).decode(buffer);
    let riskScore = 0;
    
    const suspiciousAPIs = SUSPICIOUS_APIS.filter(api => text.includes(api));
    riskScore += suspiciousAPIs.length * 8;
    
    // Simular conex√µes de rede suspeitas
    const networkConnections: NetworkConnection[] = [];
    const urlPattern = /https?:\/\/[^\s]+/g;
    const urls = text.match(urlPattern) || [];
    
    for (const url of urls.slice(0, 5)) {
      try {
        const urlObj = new URL(url);
        const suspicious = this.isSuspiciousURL(urlObj);
        networkConnections.push({
          protocol: urlObj.protocol,
          destination: urlObj.hostname,
          port: urlObj.port ? parseInt(urlObj.port) : (urlObj.protocol === 'https:' ? 443 : 80),
          suspicious,
          reason: suspicious ? 'Dom√≠nio suspeito' : undefined
        });
        
        if (suspicious) {
          riskScore += 15;
        }
      } catch {
        // URL inv√°lida
      }
    }
    
    return {
      suspiciousAPIs,
      networkConnections,
      fileOperations: [], // Simulado
      registryOperations: [], // Simulado
      processCreation: [], // Simulado
      memoryOperations: [], // Simulado
      riskScore: Math.min(riskScore, 100)
    };
  }
  
  private async detectBySignature(buffer: ArrayBuffer, fileName: string): Promise<MalwareThreat[]> {
    const threats: MalwareThreat[] = [];
    const data = new Uint8Array(buffer);
    const text = new TextDecoder('utf-8', { fatal: false }).decode(buffer);
    
    for (const signature of this.signatures.values()) {
      if (!signature.active) continue;
      
      let match = false;
      
      if (typeof signature.pattern === 'string') {
        match = text.includes(signature.pattern);
      } else if (signature.pattern instanceof RegExp) {
        match = signature.pattern.test(text);
      }
      
      if (match) {
        const threat = await this.createThreat(
          signature.type,
          signature.severity,
          signature.name,
          signature.description,
          signature.id,
          'SIGNATURE',
          signature.confidence,
          {
            fileName,
            fileSize: buffer.byteLength,
            signatureFamily: signature.family
          }
        );
        
        threats.push(threat);
      }
    }
    
    return threats;
  }
  
  private async detectByHeuristics(buffer: ArrayBuffer, fileName: string, staticAnalysis: StaticAnalysis): Promise<MalwareThreat[]> {
    const threats: MalwareThreat[] = [];
    
    // Heur√≠stica: Alta entropia + APIs suspeitas
    if (staticAnalysis.entropy > 7.5 && staticAnalysis.imports.length > 5) {
      const threat = await this.createThreat(
        'SUSPICIOUS',
        'MEDIUM',
        'Heuristic.HighEntropy',
        'Arquivo com alta entropia e APIs suspeitas',
        'heuristic-entropy',
        'HEURISTIC',
        75,
        {
          fileName,
          entropy: staticAnalysis.entropy,
          suspiciousAPIs: staticAnalysis.imports.length
        }
      );
      threats.push(threat);
    }
    
    // Heur√≠stica: Muitas strings suspeitas
    if (staticAnalysis.suspiciousStrings.length > 10) {
      const threat = await this.createThreat(
        'SUSPICIOUS',
        'MEDIUM',
        'Heuristic.SuspiciousStrings',
        'Muitas strings suspeitas detectadas',
        'heuristic-strings',
        'HEURISTIC',
        70,
        {
          fileName,
          suspiciousStrings: staticAnalysis.suspiciousStrings.length
        }
      );
      threats.push(threat);
    }
    
    // Heur√≠stica: Arquivo empacotado
    if (staticAnalysis.packedSections) {
      const threat = await this.createThreat(
        'SUSPICIOUS',
        'LOW',
        'Heuristic.PackedFile',
        'Arquivo possivelmente empacotado',
        'heuristic-packed',
        'HEURISTIC',
        60,
        {
          fileName,
          entropy: staticAnalysis.entropy
        }
      );
      threats.push(threat);
    }
    
    return threats;
  }
  
  private calculateEntropy(data: Uint8Array): number {
    const frequency = new Array(256).fill(0);
    
    for (const byte of data) {
      frequency[byte]++;
    }
    
    let entropy = 0;
    const length = data.length;
    
    for (const count of frequency) {
      if (count > 0) {
        const probability = count / length;
        entropy -= probability * Math.log2(probability);
      }
    }
    
    return entropy;
  }
  
  private detectObfuscation(text: string): number {
    let score = 0;
    
    // Verificar base64
    const base64Pattern = /[A-Za-z0-9+\/]{20,}={0,2}/g;
    const base64Matches = text.match(base64Pattern) || [];
    score += base64Matches.length * 5;
    
    // Verificar hex encoding
    const hexPattern = /\\x[0-9a-fA-F]{2}/g;
    const hexMatches = text.match(hexPattern) || [];
    score += hexMatches.length * 2;
    
    // Verificar unicode escapes
    const unicodePattern = /\\u[0-9a-fA-F]{4}/g;
    const unicodeMatches = text.match(unicodePattern) || [];
    score += unicodeMatches.length * 3;
    
    // Verificar eval/exec patterns
    const evalPattern = /(eval|exec|Function)\s*\(/gi;
    const evalMatches = text.match(evalPattern) || [];
    score += evalMatches.length * 15;
    
    return Math.min(score, 100);
  }
  
  private detectFileType(buffer: ArrayBuffer): string {
    const data = new Uint8Array(buffer);
    
    // Magic numbers para detec√ß√£o de tipo
    if (data[0] === 0x4D && data[1] === 0x5A) {
      return 'PE'; // Windows executable
    }
    if (data[0] === 0x7F && data[1] === 0x45 && data[2] === 0x4C && data[3] === 0x46) {
      return 'ELF'; // Linux executable
    }
    if (data[0] === 0xCF && data[1] === 0xFA && data[2] === 0xED && data[3] === 0xFE) {
      return 'Mach-O'; // macOS executable
    }
    if (data[0] === 0x50 && data[1] === 0x4B) {
      return 'ZIP'; // ZIP/JAR/APK
    }
    if (data[0] === 0xFF && data[1] === 0xD8 && data[2] === 0xFF) {
      return 'JPEG';
    }
    if (data[0] === 0x89 && data[1] === 0x50 && data[2] === 0x4E && data[3] === 0x47) {
      return 'PNG';
    }
    
    return 'UNKNOWN';
  }
  
  private async calculateFileHash(buffer: ArrayBuffer): Promise<string> {
    const data = new Uint8Array(buffer);
    const hex = Array.from(data)
      .map(byte => byte.toString(16).padStart(2, '0'))
      .join('');
    return await hash.sha256(hex);
  }
  
  private isSuspiciousURL(url: URL): boolean {
    const suspiciousTLDs = ['.tk', '.ml', '.ga', '.cf', '.click'];
    const suspiciousKeywords = ['download', 'free', 'crack', 'keygen', 'hack'];
    
    // Verificar TLD suspeito
    for (const tld of suspiciousTLDs) {
      if (url.hostname.endsWith(tld)) {
        return true;
      }
    }
    
    // Verificar palavras-chave suspeitas
    for (const keyword of suspiciousKeywords) {
      if (url.href.toLowerCase().includes(keyword)) {
        return true;
      }
    }
    
    // Verificar IP em vez de dom√≠nio
    if (/^\d+\.\d+\.\d+\.\d+$/.test(url.hostname)) {
      return true;
    }
    
    return false;
  }
  
  private async createThreat(
    type: MalwareType,
    severity: ThreatSeverity,
    name: string,
    description: string,
    signature: string,
    detectionMethod: DetectionMethod,
    confidence: number,
    metadata: Record<string, any>
  ): Promise<MalwareThreat> {
    const threat: MalwareThreat = {
      id: await generateSecureToken(16),
      type,
      severity,
      name,
      description,
      signature,
      fileHash: metadata.fileHash,
      fileName: metadata.fileName,
      fileSize: metadata.fileSize,
      detectionMethod,
      confidence,
      timestamp: Date.now(),
      source: 'INTERNAL',
      blocked: false,
      quarantined: false,
      metadata
    };
    
    this.threats.set(threat.id, threat);
    
    // Limitar n√∫mero de amea√ßas
    if (this.threats.size > 10000) {
      const oldestThreat = Array.from(this.threats.values())
        .sort((a, b) => a.timestamp - b.timestamp)[0];
      this.threats.delete(oldestThreat.id);
    }
    
    return threat;
  }
  
  private async quarantineFile(analysis: FileAnalysis): Promise<void> {
    this.quarantine.set(analysis.fileHash, analysis);
    
    // Gerar alerta
    await this.generateAlert(
      'FILE_QUARANTINED',
      'HIGH',
      'Arquivo em Quarentena',
      `O arquivo ${analysis.fileName} foi colocado em quarentena devido a amea√ßas detectadas.`,
      analysis.threats[0]?.id || '',
      analysis.fileName,
      analysis.fileHash
    );
    
    await securityLogger.logEvent(
      'FILE_QUARANTINED',
      'HIGH',
      'Arquivo colocado em quarentena',
      {
        fileName: analysis.fileName,
        fileHash: analysis.fileHash,
        riskScore: analysis.riskScore,
        threatsFound: analysis.threats.length
      }
    );
  }
  
  private async generateAlert(
    type: AlertType,
    severity: ThreatSeverity,
    title: string,
    message: string,
    threatId: string,
    fileName?: string,
    fileHash?: string
  ): Promise<void> {
    const alert: MalwareAlert = {
      id: await generateSecureToken(16),
      type,
      severity,
      title,
      message,
      threatId,
      fileName,
      fileHash,
      timestamp: Date.now(),
      acknowledged: false,
      actions: [],
      quarantined: type === 'FILE_QUARANTINED'
    };
    
    this.alerts.push(alert);
    
    // Limitar n√∫mero de alertas
    if (this.alerts.length > 1000) {
      this.alerts.splice(0, this.alerts.length - 1000);
    }
  }
  
  private createCleanAnalysis(fileName: string, size: number, startTime: number): FileAnalysis {
    return {
      fileName,
      fileSize: size,
      fileType: 'UNKNOWN',
      fileHash: '',
      isMalicious: false,
      riskScore: 0,
      threats: [],
      signatures: [],
      behaviorAnalysis: {
        suspiciousAPIs: [],
        networkConnections: [],
        fileOperations: [],
        registryOperations: [],
        processCreation: [],
        memoryOperations: [],
        riskScore: 0
      },
      staticAnalysis: {
        entropy: 0,
        packedSections: false,
        suspiciousStrings: [],
        imports: [],
        exports: [],
        certificates: [],
        metadata: {
          version: '',
          company: '',
          description: '',
          copyright: '',
          originalFilename: fileName
        },
        riskScore: 0
      },
      timestamp: Date.now(),
      scanDuration: Date.now() - startTime
    };
  }
  
  private createErrorAnalysis(fileName: string, startTime: number): FileAnalysis {
    return {
      fileName,
      fileSize: 0,
      fileType: 'ERROR',
      fileHash: '',
      isMalicious: false,
      riskScore: 0,
      threats: [],
      signatures: [],
      behaviorAnalysis: {
        suspiciousAPIs: [],
        networkConnections: [],
        fileOperations: [],
        registryOperations: [],
        processCreation: [],
        memoryOperations: [],
        riskScore: 0
      },
      staticAnalysis: {
        entropy: 0,
        packedSections: false,
        suspiciousStrings: [],
        imports: [],
        exports: [],
        certificates: [],
        metadata: {
          version: '',
          company: '',
          description: '',
          copyright: '',
          originalFilename: fileName
        },
        riskScore: 0
      },
      timestamp: Date.now(),
      scanDuration: Date.now() - startTime
    };
  }
  
  private loadSignatures(): void {
    for (const signature of MALWARE_SIGNATURES) {
      this.signatures.set(signature.id, signature);
    }
  }
  
  private startRealTimeProtection(): void {
    if (!this.realTimeProtection) return;
    
    // Monitorar uploads de arquivo (simulado)
    if (typeof window !== 'undefined') {
      const originalCreateElement = document.createElement;
      document.createElement = function(tagName: string) {
        const element = originalCreateElement.call(this, tagName);
        
        if (tagName.toLowerCase() === 'input' && element instanceof HTMLInputElement) {
          element.addEventListener('change', async (event) => {
            const input = event.target as HTMLInputElement;
            if (input.type === 'file' && input.files) {
              for (const file of Array.from(input.files)) {
                const analysis = await malwareProtection.scanFile(file);
                if (analysis.isMalicious) {
                  input.value = ''; // Limpar input
                  // alert(`Arquivo ${file.name} bloqueado: malware detectado!`);
                }
              }
            }
          });
        }
        
        return element;
      };
    }
  }
}

// Inst√¢ncia singleton
export const malwareProtection = MalwareProtection.getInstance();

// Middleware para verifica√ß√£o de uploads
export const malwareMiddleware = async (req: any, res: any, next: any) => {
  try {
    if (req.files && Array.isArray(req.files)) {
      for (const file of req.files) {
        const analysis = await malwareProtection.scanFile(file.buffer, file.originalname);
        
        if (analysis.isMalicious) {
          return res.status(403).json({
            error: 'Upload bloqueado',
            reason: 'Malware detectado no arquivo',
            fileName: file.originalname,
            threats: analysis.threats.map(t => t.name)
          });
        }
        
        req.malwareAnalysis = analysis;
      }
    }
    
    next();
  } catch (error) {
    console.error('Erro no middleware de malware:', error);
    next();
  }
};

// Hook para React
export const useMalwareProtection = () => {
  const scanFile = async (file: File) => {
    return await malwareProtection.scanFile(file);
  };
  
  const scanFiles = async (files: File[]) => {
    return await malwareProtection.scanFiles(files);
  };
  
  const scanText = async (text: string, context?: string) => {
    return await malwareProtection.scanText(text, context);
  };
  
  const getStatistics = () => {
    return malwareProtection.getStatistics();
  };
  
  const getThreats = (type?: MalwareType, severity?: ThreatSeverity) => {
    return malwareProtection.getThreats(type, severity);
  };
  
  const getQuarantinedFiles = () => {
    return malwareProtection.getQuarantinedFiles();
  };
  
  const getAlerts = (acknowledged = false) => {
    return malwareProtection.getAlerts(acknowledged);
  };
  
  const acknowledgeAlert = (alertId: string) => {
    return malwareProtection.acknowledgeAlert(alertId);
  };
  
  const removeFromQuarantine = async (fileHash: string, reason: string) => {
    return await malwareProtection.removeFromQuarantine(fileHash, reason);
  };
  
  return {
    scanFile,
    scanFiles,
    scanText,
    getStatistics,
    getThreats,
    getQuarantinedFiles,
    getAlerts,
    acknowledgeAlert,
    removeFromQuarantine
  };
};

console.log('ü¶† Sistema de prote√ß√£o contra malware inicializado');

// Exportar para uso global
(window as any).__malwareProtection = malwareProtection;

// Exportar tipos
export type {
  MalwareSignature,
  MalwareThreat,
  FileAnalysis,
  BehaviorAnalysis,
  StaticAnalysis,
  MalwareAlert,
  MalwareStatistics,
  MalwareType,
  ThreatSeverity,
  DetectionMethod,
  AlertType
};